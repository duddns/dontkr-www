<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>컨테이너 기초 용어 정리 | DoNT - Do Not Think!!!</title>
<meta name="keywords" content="container, docker, ecs">
<meta name="description" content="물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.
서버 환경의 변천
물리 서버 → VM  → 컨테이너
물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.
패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.
컨테이너의 구조
기존 서버 환경 (물리 서버 / VM)
Application (jar)
Java (JDK)
OS (Linux)
─────────────
물리 서버 / VM
기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.">
<meta name="author" content="">
<link rel="canonical" href="https://dont.kr/posts/2026/2026-02-09-container-basics/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f56f6fcbbbf1b56135b161970b2be054c0f93cd0507af71fddbab4cf707c5c56.css" integrity="sha256-9W9vy7vxtWE1sWGXCyvgVMD5PNBQevcf3bq0z3B8XFY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dont.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dont.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dont.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dont.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://dont.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://dont.kr/posts/2026/2026-02-09-container-basics/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://dont.kr/posts/2026/2026-02-09-container-basics/">
  <meta property="og:site_name" content="DoNT - Do Not Think!!!">
  <meta property="og:title" content="컨테이너 기초 용어 정리">
  <meta property="og:description" content="물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.
서버 환경의 변천 물리 서버 → VM → 컨테이너 물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.
패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.
컨테이너의 구조 기존 서버 환경 (물리 서버 / VM) Application (jar) Java (JDK) OS (Linux) ───────────── 물리 서버 / VM 기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-09T00:00:00+09:00">
    <meta property="article:modified_time" content="2026-02-09T00:00:00+09:00">
    <meta property="article:tag" content="Container">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="Ecs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="컨테이너 기초 용어 정리">
<meta name="twitter:description" content="물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.
서버 환경의 변천
물리 서버 → VM  → 컨테이너
물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.
패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.
컨테이너의 구조
기존 서버 환경 (물리 서버 / VM)
Application (jar)
Java (JDK)
OS (Linux)
─────────────
물리 서버 / VM
기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dont.kr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "컨테이너 기초 용어 정리",
      "item": "https://dont.kr/posts/2026/2026-02-09-container-basics/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "컨테이너 기초 용어 정리",
  "name": "컨테이너 기초 용어 정리",
  "description": "물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.\n서버 환경의 변천 물리 서버 → VM → 컨테이너 물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.\n패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.\n컨테이너의 구조 기존 서버 환경 (물리 서버 / VM) Application (jar) Java (JDK) OS (Linux) ───────────── 물리 서버 / VM 기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.\n",
  "keywords": [
    "container", "docker", "ecs"
  ],
  "articleBody": "물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.\n서버 환경의 변천 물리 서버 → VM → 컨테이너 물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.\n패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.\n컨테이너의 구조 기존 서버 환경 (물리 서버 / VM) Application (jar) Java (JDK) OS (Linux) ───────────── 물리 서버 / VM 기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.\n컨테이너 ┌─ 컨테이너 ──────────┐ │ Application (jar) │ │ Java (JDK) │ │ 최소한의 OS 라이브러리 │ └──────────────────────┘ ───────────── 호스트 OS 커널 (공유) ───────────── 물리 서버 / VM 컨테이너는 호스트의 OS 커널을 공유합니다. OS를 통째로 설치하지 않고, 앱 실행에 필요한 최소한만 패키징합니다. 그래서 기존 서버 환경보다 가볍고 빠릅니다.\nOS 커널, OS 라이브러리 OS는 커널과 라이브러리로 구성됩니다.\nOS = 커널 + 라이브러리 (유저스페이스) 구분 역할 컨테이너에서 OS 커널 하드웨어 제어, 메모리 관리, 프로세스 관리 호스트 것을 공유 OS 라이브러리 앱이 파일을 읽거나 네트워크 통신할 때 사용 이미지에 포함 Java는 직접 OS 커널과 통신하지 않고, OS 라이브러리(glibc 등)를 통해 OS 커널 기능을 사용합니다.\nJava → OS 라이브러리 (이미지에 포함) → OS 커널 (호스트 공유) 그래서 이미지에 “최소한의 OS 라이브러리\"가 필요합니다. 다만 OS를 통째로 넣는 게 아니라 최소한만 포함하므로, 크기 차이가 큽니다.\n구분 크기 일반 OS 설치 (Ubuntu) 수 GB 컨테이너 OS 베이스 이미지 (Alpine Linux) 수십 MB 컨테이너 Java 베이스 이미지 (amazoncorretto:21) 200~400MB 용어 관계 이미지와 컨테이너 용어 프로그래밍 비유 설명 이미지 클래스 (설계도) 앱 실행에 필요한 모든 것을 패키징한 결과물. 불변(immutable) 컨테이너 인스턴스 (실행체) 이미지를 실행한 프로세스 이미지 하나로 컨테이너 여러 개를 실행할 수 있습니다.\n[이미지] ├→ 컨테이너 1 (운영 서버) ├→ 컨테이너 2 (운영 서버) └→ 컨테이너 3 (운영 서버) 이미지를 만드는 흐름 Dockerfile (설치 매뉴얼 작성) ↓ 빌드 이미지 (스냅샷 생성) ↓ 실행 컨테이너 (실행) Spring Boot 기준 Dockerfile 예시:\nFROM amazoncorretto:21 # 베이스 이미지 (OS 라이브러리 + Java) COPY app.jar /app/app.jar # 애플리케이션 (jar) ENTRYPOINT [\"java\", \"-jar\", \"/app/app.jar\"] # 실행 명령어 베이스 이미지를 선택하면 OS 라이브러리와 Java가 자동으로 포함됩니다. 개발자가 OS 라이브러리를 직접 설치할 일은 거의 없습니다.\n이미지 용어 정리 같은 것을 문맥에 따라 다르게 부릅니다.\n컨테이너 이미지 = Docker 이미지 = OCI 이미지 = 이미지 컨테이너 이미지: 정식 명칭 Docker 이미지: Docker가 유명해서 대명사처럼 사용 OCI 이미지: 표준 스펙 이름 (Open Container Initiative) 이미지: 실무에서 줄여서 부르는 표현 Docker가 만든 이미지 포맷이 OCI 표준으로 정리된 것이므로, 사실상 모두 같은 의미입니다.\n컨테이너 생태계 이미지 포맷 OCI (Open Container Initiative) 가 표준입니다. Docker에서 유래했고, 어떤 빌드 도구로 만들든 결과물은 동일한 OCI 이미지입니다.\n이미지 빌드 도구 이미지를 생성하는 도구입니다.\n도구 특징 Docker 가장 유명. 범용 Jib (Google) Docker 없이 빌드 가능. Java 전용 Kaniko (Google) Docker 없이 빌드 가능. CI/CD 환경 Buildpacks Spring Boot 공식 지원. Dockerfile 불필요 Jib은 Docker 데몬 없이 Java 레벨에서 직접 OCI 이미지를 만듭니다. Java 생태계에서 많이 사용합니다.\n런타임 (실행 도구) 컨테이너 1개를 실행하는 도구입니다.\n런타임 특징 Docker 가장 유명. 빌드 + 실행 모두 가능 containerd Docker 내부에서 쓰이던 런타임. 더 가벼움 Podman Docker 대체제. Red Hat 계열에서 선호 오케스트레이션 (운영/관리 도구) 컨테이너 여러 개를 운영/관리하는 도구입니다. 내부적으로 런타임을 사용해서 컨테이너를 실행합니다.\n오케스트레이션 (ECS, Kubernetes) ↓ 사용 런타임 (containerd 등) ↓ 실행 컨테이너 도구 특징 AWS ECS AWS 전용. 간편 Kubernetes 범용 (멀티 클라우드, 온프레미스). 복잡 ECS는 containerd를 이용해서 컨테이너를 실행하고, 추가로 오토스케일링, 로드밸런싱, 무중단 배포 등 운영/관리를 해줍니다.\n전체 흐름 빌드 → 저장 → 배포 → 실행 → 관리 단계 동작 도구 빌드 이미지 생성 Docker, Jib 등 저장 이미지를 저장소에 업로드 Docker Hub, AWS ECR 등 배포 저장소에서 이미지 다운로드 오케스트레이션이 처리 실행 컨테이너 실행 오케스트레이션이 처리 관리 모니터링, 재시작, 스케일링 오케스트레이션이 처리 개발자는 이미지를 빌드해서 저장소에 올리기까지만 하고, 이후는 오케스트레이션 도구(ECS 등)가 처리합니다.\n[개발자] [오케스트레이션 (ECS)] 빌드 → 저장 → 배포 → 실행 → 관리 ",
  "wordCount" : "611",
  "inLanguage": "ko",
  "datePublished": "2026-02-09T00:00:00+09:00",
  "dateModified": "2026-02-09T00:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dont.kr/posts/2026/2026-02-09-container-basics/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DoNT - Do Not Think!!!",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dont.kr/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dont.kr/" accesskey="h" title="DoNT - Do Not Think!!! (Alt + H)">DoNT - Do Not Think!!!</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dont.kr/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dont.kr/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      컨테이너 기초 용어 정리
    </h1>
    <div class="post-meta"><span title='2026-02-09 00:00:00 +0900 KST'>2026년 2월 9일</span>

</div>
  </header> 
  <div class="post-content"><p>물리 서버, 가상 머신 (VM), 컨테이너. 서버 환경이 어떻게 변해왔는지, 컨테이너 관련 용어들의 관계를 정리합니다.</p>
<h2 id="서버-환경의-변천">서버 환경의 변천<a hidden class="anchor" aria-hidden="true" href="#서버-환경의-변천">#</a></h2>
<pre tabindex="0"><code>물리 서버 → VM  → 컨테이너
</code></pre><p>물리 서버와 VM은 사용자 입장에서 거의 동일합니다. OS 설치하고, Java 설치하고, jar 배포하고. 차이는 하드웨어를 직접 만지느냐, 콘솔에서 클릭하느냐 정도입니다.</p>
<p>패러다임이 바뀌는 건 VM → 컨테이너 구간입니다.</p>
<h2 id="컨테이너의-구조">컨테이너의 구조<a hidden class="anchor" aria-hidden="true" href="#컨테이너의-구조">#</a></h2>
<h3 id="기존-서버-환경-물리-서버--vm">기존 서버 환경 (물리 서버 / VM)<a hidden class="anchor" aria-hidden="true" href="#기존-서버-환경-물리-서버--vm">#</a></h3>
<pre tabindex="0"><code>Application (jar)
Java (JDK)
OS (Linux)
─────────────
물리 서버 / VM
</code></pre><p>기존 서버 환경은 각 계층을 하나하나 직접 설치합니다.</p>
<h3 id="컨테이너">컨테이너<a hidden class="anchor" aria-hidden="true" href="#컨테이너">#</a></h3>
<pre tabindex="0"><code>┌─ 컨테이너 ──────────┐
│  Application (jar)   │
│  Java (JDK)          │
│  최소한의 OS 라이브러리  │
└──────────────────────┘
─────────────
호스트 OS 커널 (공유)
─────────────
물리 서버 / VM
</code></pre><p>컨테이너는 호스트의 OS 커널을 공유합니다. OS를 통째로 설치하지 않고, 앱 실행에 필요한 최소한만 패키징합니다. 그래서 기존 서버 환경보다 가볍고 빠릅니다.</p>
<h3 id="os-커널-os-라이브러리">OS 커널, OS 라이브러리<a hidden class="anchor" aria-hidden="true" href="#os-커널-os-라이브러리">#</a></h3>
<p>OS는 커널과 라이브러리로 구성됩니다.</p>
<pre tabindex="0"><code>OS = 커널 + 라이브러리 (유저스페이스)
</code></pre><table>
  <thead>
      <tr>
          <th>구분</th>
          <th>역할</th>
          <th>컨테이너에서</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>OS 커널</td>
          <td>하드웨어 제어, 메모리 관리, 프로세스 관리</td>
          <td>호스트 것을 공유</td>
      </tr>
      <tr>
          <td>OS 라이브러리</td>
          <td>앱이 파일을 읽거나 네트워크 통신할 때 사용</td>
          <td>이미지에 포함</td>
      </tr>
  </tbody>
</table>
<p>Java는 직접 OS 커널과 통신하지 않고, OS 라이브러리(glibc 등)를 통해 OS 커널 기능을 사용합니다.</p>
<pre tabindex="0"><code>Java → OS 라이브러리 (이미지에 포함) → OS 커널 (호스트 공유)
</code></pre><p>그래서 이미지에 &ldquo;최소한의 OS 라이브러리&quot;가 필요합니다. 다만 OS를 통째로 넣는 게 아니라 최소한만 포함하므로, 크기 차이가 큽니다.</p>
<table>
  <thead>
      <tr>
          <th>구분</th>
          <th>크기</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>일반 OS 설치 (Ubuntu)</td>
          <td>수 GB</td>
      </tr>
      <tr>
          <td>컨테이너 OS 베이스 이미지 (Alpine Linux)</td>
          <td>수십 MB</td>
      </tr>
      <tr>
          <td>컨테이너 Java 베이스 이미지 (amazoncorretto:21)</td>
          <td>200~400MB</td>
      </tr>
  </tbody>
</table>
<h2 id="용어-관계">용어 관계<a hidden class="anchor" aria-hidden="true" href="#용어-관계">#</a></h2>
<h3 id="이미지와-컨테이너">이미지와 컨테이너<a hidden class="anchor" aria-hidden="true" href="#이미지와-컨테이너">#</a></h3>
<table>
  <thead>
      <tr>
          <th>용어</th>
          <th>프로그래밍 비유</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>이미지</td>
          <td>클래스 (설계도)</td>
          <td>앱 실행에 필요한 모든 것을 패키징한 결과물. 불변(immutable)</td>
      </tr>
      <tr>
          <td>컨테이너</td>
          <td>인스턴스 (실행체)</td>
          <td>이미지를 실행한 프로세스</td>
      </tr>
  </tbody>
</table>
<p>이미지 하나로 컨테이너 여러 개를 실행할 수 있습니다.</p>
<pre tabindex="0"><code>[이미지]
  ├→ 컨테이너 1 (운영 서버)
  ├→ 컨테이너 2 (운영 서버)
  └→ 컨테이너 3 (운영 서버)
</code></pre><h3 id="이미지를-만드는-흐름">이미지를 만드는 흐름<a hidden class="anchor" aria-hidden="true" href="#이미지를-만드는-흐름">#</a></h3>
<pre tabindex="0"><code>Dockerfile (설치 매뉴얼 작성)
    ↓ 빌드
이미지 (스냅샷 생성)
    ↓ 실행
컨테이너 (실행)
</code></pre><p>Spring Boot 기준 Dockerfile 예시:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> <span style="color:#e6db74">amazoncorretto:21</span>          <span style="color:#75715e"># 베이스 이미지 (OS 라이브러리 + Java)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">COPY</span> app.jar /app/app.jar       <span style="color:#75715e"># 애플리케이션 (jar)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">ENTRYPOINT</span> [<span style="color:#e6db74">&#34;java&#34;</span>, <span style="color:#e6db74">&#34;-jar&#34;</span>, <span style="color:#e6db74">&#34;/app/app.jar&#34;</span>]  <span style="color:#75715e"># 실행 명령어</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>베이스 이미지를 선택하면 OS 라이브러리와 Java가 자동으로 포함됩니다. 개발자가 OS 라이브러리를 직접 설치할 일은 거의 없습니다.</p>
<h3 id="이미지-용어-정리">이미지 용어 정리<a hidden class="anchor" aria-hidden="true" href="#이미지-용어-정리">#</a></h3>
<p>같은 것을 문맥에 따라 다르게 부릅니다.</p>
<pre tabindex="0"><code>컨테이너 이미지 = Docker 이미지 = OCI 이미지 = 이미지
</code></pre><ul>
<li>컨테이너 이미지: 정식 명칭</li>
<li>Docker 이미지: Docker가 유명해서 대명사처럼 사용</li>
<li>OCI 이미지: 표준 스펙 이름 (Open Container Initiative)</li>
<li>이미지: 실무에서 줄여서 부르는 표현</li>
</ul>
<p>Docker가 만든 이미지 포맷이 OCI 표준으로 정리된 것이므로, 사실상 모두 같은 의미입니다.</p>
<h2 id="컨테이너-생태계">컨테이너 생태계<a hidden class="anchor" aria-hidden="true" href="#컨테이너-생태계">#</a></h2>
<h3 id="이미지-포맷">이미지 포맷<a hidden class="anchor" aria-hidden="true" href="#이미지-포맷">#</a></h3>
<p>OCI (Open Container Initiative) 가 표준입니다. Docker에서 유래했고, 어떤 빌드 도구로 만들든 결과물은 동일한 OCI 이미지입니다.</p>
<h3 id="이미지-빌드-도구">이미지 빌드 도구<a hidden class="anchor" aria-hidden="true" href="#이미지-빌드-도구">#</a></h3>
<p>이미지를 생성하는 도구입니다.</p>
<table>
  <thead>
      <tr>
          <th>도구</th>
          <th>특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Docker</td>
          <td>가장 유명. 범용</td>
      </tr>
      <tr>
          <td>Jib (Google)</td>
          <td>Docker 없이 빌드 가능. Java 전용</td>
      </tr>
      <tr>
          <td>Kaniko (Google)</td>
          <td>Docker 없이 빌드 가능. CI/CD 환경</td>
      </tr>
      <tr>
          <td>Buildpacks</td>
          <td>Spring Boot 공식 지원. Dockerfile 불필요</td>
      </tr>
  </tbody>
</table>
<p>Jib은 Docker 데몬 없이 Java 레벨에서 직접 OCI 이미지를 만듭니다. Java 생태계에서 많이 사용합니다.</p>
<h3 id="런타임-실행-도구">런타임 (실행 도구)<a hidden class="anchor" aria-hidden="true" href="#런타임-실행-도구">#</a></h3>
<p>컨테이너 1개를 실행하는 도구입니다.</p>
<table>
  <thead>
      <tr>
          <th>런타임</th>
          <th>특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Docker</td>
          <td>가장 유명. 빌드 + 실행 모두 가능</td>
      </tr>
      <tr>
          <td>containerd</td>
          <td>Docker 내부에서 쓰이던 런타임. 더 가벼움</td>
      </tr>
      <tr>
          <td>Podman</td>
          <td>Docker 대체제. Red Hat 계열에서 선호</td>
      </tr>
  </tbody>
</table>
<h3 id="오케스트레이션-운영관리-도구">오케스트레이션 (운영/관리 도구)<a hidden class="anchor" aria-hidden="true" href="#오케스트레이션-운영관리-도구">#</a></h3>
<p>컨테이너 여러 개를 운영/관리하는 도구입니다. 내부적으로 런타임을 사용해서 컨테이너를 실행합니다.</p>
<pre tabindex="0"><code>오케스트레이션 (ECS, Kubernetes)
    ↓ 사용
런타임 (containerd 등)
    ↓ 실행
컨테이너
</code></pre><table>
  <thead>
      <tr>
          <th>도구</th>
          <th>특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>AWS ECS</td>
          <td>AWS 전용. 간편</td>
      </tr>
      <tr>
          <td>Kubernetes</td>
          <td>범용 (멀티 클라우드, 온프레미스). 복잡</td>
      </tr>
  </tbody>
</table>
<p>ECS는 containerd를 이용해서 컨테이너를 실행하고, 추가로 오토스케일링, 로드밸런싱, 무중단 배포 등 운영/관리를 해줍니다.</p>
<h2 id="전체-흐름">전체 흐름<a hidden class="anchor" aria-hidden="true" href="#전체-흐름">#</a></h2>
<pre tabindex="0"><code>빌드 → 저장 → 배포 → 실행 → 관리
</code></pre><table>
  <thead>
      <tr>
          <th>단계</th>
          <th>동작</th>
          <th>도구</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>빌드</td>
          <td>이미지 생성</td>
          <td>Docker, Jib 등</td>
      </tr>
      <tr>
          <td>저장</td>
          <td>이미지를 저장소에 업로드</td>
          <td>Docker Hub, AWS ECR 등</td>
      </tr>
      <tr>
          <td>배포</td>
          <td>저장소에서 이미지 다운로드</td>
          <td>오케스트레이션이 처리</td>
      </tr>
      <tr>
          <td>실행</td>
          <td>컨테이너 실행</td>
          <td>오케스트레이션이 처리</td>
      </tr>
      <tr>
          <td>관리</td>
          <td>모니터링, 재시작, 스케일링</td>
          <td>오케스트레이션이 처리</td>
      </tr>
  </tbody>
</table>
<p>개발자는 이미지를 빌드해서 저장소에 올리기까지만 하고, 이후는 오케스트레이션 도구(ECS 등)가 처리합니다.</p>
<pre tabindex="0"><code>[개발자]              [오케스트레이션 (ECS)]
빌드 → 저장 → 배포 → 실행 → 관리
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dont.kr/tags/container/">Container</a></li>
      <li><a href="https://dont.kr/tags/docker/">Docker</a></li>
      <li><a href="https://dont.kr/tags/ecs/">Ecs</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
    data-repo="duddns/dontkr-www"
    data-repo-id="R_kgDOJ5uOLg"
    data-category="General"
    data-category-id="DIC_kwDOJ5uOLs4CzVRe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="ko"
    crossorigin="anonymous"
    async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://dont.kr/">DoNT - Do Not Think!!!</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
