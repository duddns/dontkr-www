<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kotlin의 접근 제어자 설계 철학 | DoNT - Do Not Think!!!</title>
<meta name="keywords" content="kotlin, access modifier">
<meta name="description" content="Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?
Java와 Kotlin 접근 제어자 비교
Java

public: 전체
protected: 상속 &#43; 같은 패키지
(default): 같은 패키지
private: 같은 클래스

Kotlin

public: 전체
internal: 같은 모듈
protected: 상속 관계만
private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언)

핵심 차이

  
      
          
          Java
          Kotlin
      
  
  
      
          캡슐화 단위
          패키지
          모듈
      
      
          테스트 접근
          같은 패키지 필요
          같은 모듈이면 OK
      
      
          package-private
          있음
          없음 (internal로 대체)
      
      
          protected
          상속 &#43; 같은 패키지
          상속만
      
  

Kotlin의 설계 철학
1. 패키지는 캡슐화 경계가 아니다
// 원래 라이브러리 (example-lib.jar)
package com.example.core;

class InternalClass {  // package-private
    void sensitiveMethod() { }
}
// 악의적 사용자 코드 (다른 프로젝트)
package com.example.core; // 같은 패키지명 사용

public class Hacker {
    void access() {
        new InternalClass();  // package-private인데 접근됨
    }
}
패키지는 코드 조직화 수단일 뿐, 실제 캡슐화는 컴파일/배포 단위인 모듈에서 이루어져야 합니다.">
<meta name="author" content="">
<link rel="canonical" href="https://dont.kr/posts/2026/2026-01-13-kotlin-access-modifier/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f56f6fcbbbf1b56135b161970b2be054c0f93cd0507af71fddbab4cf707c5c56.css" integrity="sha256-9W9vy7vxtWE1sWGXCyvgVMD5PNBQevcf3bq0z3B8XFY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dont.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dont.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dont.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dont.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://dont.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://dont.kr/posts/2026/2026-01-13-kotlin-access-modifier/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://dont.kr/posts/2026/2026-01-13-kotlin-access-modifier/">
  <meta property="og:site_name" content="DoNT - Do Not Think!!!">
  <meta property="og:title" content="Kotlin의 접근 제어자 설계 철학">
  <meta property="og:description" content="Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?
Java와 Kotlin 접근 제어자 비교 Java public: 전체 protected: 상속 &#43; 같은 패키지 (default): 같은 패키지 private: 같은 클래스 Kotlin public: 전체 internal: 같은 모듈 protected: 상속 관계만 private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언) 핵심 차이 Java Kotlin 캡슐화 단위 패키지 모듈 테스트 접근 같은 패키지 필요 같은 모듈이면 OK package-private 있음 없음 (internal로 대체) protected 상속 &#43; 같은 패키지 상속만 Kotlin의 설계 철학 1. 패키지는 캡슐화 경계가 아니다 // 원래 라이브러리 (example-lib.jar) package com.example.core; class InternalClass { // package-private void sensitiveMethod() { } } // 악의적 사용자 코드 (다른 프로젝트) package com.example.core; // 같은 패키지명 사용 public class Hacker { void access() { new InternalClass(); // package-private인데 접근됨 } } 패키지는 코드 조직화 수단일 뿐, 실제 캡슐화는 컴파일/배포 단위인 모듈에서 이루어져야 합니다.">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-13T00:00:00+09:00">
    <meta property="article:modified_time" content="2026-01-13T00:00:00+09:00">
    <meta property="article:tag" content="Kotlin">
    <meta property="article:tag" content="Access Modifier">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin의 접근 제어자 설계 철학">
<meta name="twitter:description" content="Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?
Java와 Kotlin 접근 제어자 비교
Java

public: 전체
protected: 상속 &#43; 같은 패키지
(default): 같은 패키지
private: 같은 클래스

Kotlin

public: 전체
internal: 같은 모듈
protected: 상속 관계만
private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언)

핵심 차이

  
      
          
          Java
          Kotlin
      
  
  
      
          캡슐화 단위
          패키지
          모듈
      
      
          테스트 접근
          같은 패키지 필요
          같은 모듈이면 OK
      
      
          package-private
          있음
          없음 (internal로 대체)
      
      
          protected
          상속 &#43; 같은 패키지
          상속만
      
  

Kotlin의 설계 철학
1. 패키지는 캡슐화 경계가 아니다
// 원래 라이브러리 (example-lib.jar)
package com.example.core;

class InternalClass {  // package-private
    void sensitiveMethod() { }
}
// 악의적 사용자 코드 (다른 프로젝트)
package com.example.core; // 같은 패키지명 사용

public class Hacker {
    void access() {
        new InternalClass();  // package-private인데 접근됨
    }
}
패키지는 코드 조직화 수단일 뿐, 실제 캡슐화는 컴파일/배포 단위인 모듈에서 이루어져야 합니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dont.kr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kotlin의 접근 제어자 설계 철학",
      "item": "https://dont.kr/posts/2026/2026-01-13-kotlin-access-modifier/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kotlin의 접근 제어자 설계 철학",
  "name": "Kotlin의 접근 제어자 설계 철학",
  "description": "Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?\nJava와 Kotlin 접근 제어자 비교 Java public: 전체 protected: 상속 + 같은 패키지 (default): 같은 패키지 private: 같은 클래스 Kotlin public: 전체 internal: 같은 모듈 protected: 상속 관계만 private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언) 핵심 차이 Java Kotlin 캡슐화 단위 패키지 모듈 테스트 접근 같은 패키지 필요 같은 모듈이면 OK package-private 있음 없음 (internal로 대체) protected 상속 + 같은 패키지 상속만 Kotlin의 설계 철학 1. 패키지는 캡슐화 경계가 아니다 // 원래 라이브러리 (example-lib.jar) package com.example.core; class InternalClass { // package-private void sensitiveMethod() { } } // 악의적 사용자 코드 (다른 프로젝트) package com.example.core; // 같은 패키지명 사용 public class Hacker { void access() { new InternalClass(); // package-private인데 접근됨 } } 패키지는 코드 조직화 수단일 뿐, 실제 캡슐화는 컴파일/배포 단위인 모듈에서 이루어져야 합니다.\n",
  "keywords": [
    "kotlin", "access modifier"
  ],
  "articleBody": "Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?\nJava와 Kotlin 접근 제어자 비교 Java public: 전체 protected: 상속 + 같은 패키지 (default): 같은 패키지 private: 같은 클래스 Kotlin public: 전체 internal: 같은 모듈 protected: 상속 관계만 private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언) 핵심 차이 Java Kotlin 캡슐화 단위 패키지 모듈 테스트 접근 같은 패키지 필요 같은 모듈이면 OK package-private 있음 없음 (internal로 대체) protected 상속 + 같은 패키지 상속만 Kotlin의 설계 철학 1. 패키지는 캡슐화 경계가 아니다 // 원래 라이브러리 (example-lib.jar) package com.example.core; class InternalClass { // package-private void sensitiveMethod() { } } // 악의적 사용자 코드 (다른 프로젝트) package com.example.core; // 같은 패키지명 사용 public class Hacker { void access() { new InternalClass(); // package-private인데 접근됨 } } 패키지는 코드 조직화 수단일 뿐, 실제 캡슐화는 컴파일/배포 단위인 모듈에서 이루어져야 합니다.\n2. 모듈이 진짜 경계다 ┌─────────────────────────┐ │ core.jar (모듈) │ ← 배포 단위 │ │ │ internal class 계산기 │ ← 모듈 내부만 │ public class API │ ← 외부 노출 └─────────────────────────┘ JAR 파일이 실제 경계이며, internal은 이 현실을 반영합니다.\n3. 테스트 친화적 설계 module-core/ (하나의 모듈) ├── src/main/kotlin/ ← internal 정의 └── src/test/kotlin/ ← internal 접근 가능 main과 test는 같은 모듈이므로 internal 클래스에 자연스럽게 접근 가능합니다.\n반면 Java는 같은 모듈이라도 package-private 클래스를 다른 패키지의 테스트에서 접근하려면 public으로 변경하거나 같은 패키지에 테스트를 작성해야 합니다.\nJava-Kotlin 혼용 시 테스트 코드 문제 문제 상황 케이스 1: 기본 생성자 (정상 동작) // Java: src/main/java/com/example/Calculator.java class Calculator { // package-private Calculator() {} } // Kotlin: src/test/kotlin/com/example/CalculatorTest.kt class CalculatorTest { @Test fun test() { val calc = Calculator() // 정상 동작 } } 케이스 2: 파라미터 생성자 (문제 발생) // Java: private 필드 + package-private 생성자 class Calculator { private BigDecimal value; Calculator() {} // 기본 생성자 Calculator(BigDecimal value) { this.value = value; } } // Kotlin 테스트 class CalculatorTest { @Test fun test() { // IllegalAccessError 발생 val calc = Calculator(BigDecimal.ONE) // Reflection으로 우회 (기본 생성자 사용) val calc = Calculator::class.java .getDeclaredConstructor() .newInstance() val field = Calculator::class.java .getDeclaredField(\"value\") field.isAccessible = true field.set(calc, BigDecimal.ONE) } } 원인 분석 JVM 바이트코드 레벨에서 package-private은 접근 제어 플래그가 없는 특수한 상태:\nACC_PUBLIC (0x0001) ACC_PRIVATE (0x0002) 플래그 없음 = package-private private 필드 + package-private 생성자 조합에서 Kotlin 컴파일러가 이를 제대로 처리하지 못합니다.\n해결 방법 1. Java로 테스트 작성 // src/test/java/로 테스트 이동 (가장 확실) 2. public 생성자로 변경 public Calculator(BigDecimal value) { this.value = value; } 3. 테스트용 Factory 메서드 class Calculator { // 테스트를 위한 static 메서드 public static Calculator createForTest(BigDecimal value) { return new Calculator(value); } } 4. Kotlin으로 완전 마이그레이션 internal class Calculator( private val value: BigDecimal ) Kotlin 접근 제어자 설계의 트레이드오프 얻은 것 명확한 모듈 경계 테스트 접근 용이 단순한 접근 제어자 잃은 것 패키지 단위 세밀한 캡슐화 같은 모듈 내 자동완성 노이즈 기존 Java 구조와의 호환성 권장 프로젝트 구조 project/ ├── module-api/ ← 외부 노출 ├── module-domain/ ← 도메인 로직 ├── module-core/ ← 핵심 로직 └── module-infra/ ← 인프라 캡슐화가 필요하면 패키지가 아닌 모듈로 분리합니다.\n모듈 크기 선택 크기 장점 단점 작게 많이 캡슐화 명확 설정 복잡 크게 적게 단순함 internal 노출 범위 넓음 정리 Kotlin은 패키지를 조직화 수단으로, 모듈을 캡슐화 경계로 봅니다. 이는 현대적인 빌드 시스템과 멀티모듈 구조에 더 적합한 설계입니다.\n하지만 Java와 혼용 시:\npackage-private 처리에 주의 필요 protected 의미가 다름을 인지 테스트 코드 작성 시 제약 발생 가능 마이그레이션 전략:\n기존 Java는 package-private 유지 신규 모듈은 Kotlin + internal 필요시 모듈 분리 ",
  "wordCount" : "566",
  "inLanguage": "ko",
  "datePublished": "2026-01-13T00:00:00+09:00",
  "dateModified": "2026-01-13T00:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dont.kr/posts/2026/2026-01-13-kotlin-access-modifier/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DoNT - Do Not Think!!!",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dont.kr/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dont.kr/" accesskey="h" title="DoNT - Do Not Think!!! (Alt + H)">DoNT - Do Not Think!!!</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dont.kr/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dont.kr/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kotlin의 접근 제어자 설계 철학
    </h1>
    <div class="post-meta"><span title='2026-01-13 00:00:00 +0900 KST'>2026년 1월 13일</span>

</div>
  </header> 
  <div class="post-content"><p>Java package-private 클래스를 Kotlin 테스트 코드에서 접근하려니 생성자 호출이 안 되어 reflection을 써야 했습니다. 왜 이런 문제가 발생할까요?</p>
<h2 id="java와-kotlin-접근-제어자-비교">Java와 Kotlin 접근 제어자 비교<a hidden class="anchor" aria-hidden="true" href="#java와-kotlin-접근-제어자-비교">#</a></h2>
<h3 id="java">Java<a hidden class="anchor" aria-hidden="true" href="#java">#</a></h3>
<ul>
<li>public: 전체</li>
<li>protected: 상속 + 같은 패키지</li>
<li>(default): 같은 패키지</li>
<li>private: 같은 클래스</li>
</ul>
<h3 id="kotlin">Kotlin<a hidden class="anchor" aria-hidden="true" href="#kotlin">#</a></h3>
<ul>
<li>public: 전체</li>
<li>internal: 같은 모듈</li>
<li>protected: 상속 관계만</li>
<li>private: 같은 클래스 (클래스 멤버) / 같은 파일 (최상위 선언)</li>
</ul>
<h3 id="핵심-차이">핵심 차이<a hidden class="anchor" aria-hidden="true" href="#핵심-차이">#</a></h3>
<table>
  <thead>
      <tr>
          <th></th>
          <th>Java</th>
          <th>Kotlin</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>캡슐화 단위</td>
          <td>패키지</td>
          <td>모듈</td>
      </tr>
      <tr>
          <td>테스트 접근</td>
          <td>같은 패키지 필요</td>
          <td>같은 모듈이면 OK</td>
      </tr>
      <tr>
          <td>package-private</td>
          <td>있음</td>
          <td>없음 (internal로 대체)</td>
      </tr>
      <tr>
          <td>protected</td>
          <td>상속 + 같은 패키지</td>
          <td>상속만</td>
      </tr>
  </tbody>
</table>
<h2 id="kotlin의-설계-철학">Kotlin의 설계 철학<a hidden class="anchor" aria-hidden="true" href="#kotlin의-설계-철학">#</a></h2>
<h3 id="1-패키지는-캡슐화-경계가-아니다">1. 패키지는 캡슐화 경계가 아니다<a hidden class="anchor" aria-hidden="true" href="#1-패키지는-캡슐화-경계가-아니다">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 원래 라이브러리 (example-lib.jar)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.core;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InternalClass</span> {  <span style="color:#75715e">// package-private</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sensitiveMethod</span>() { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 악의적 사용자 코드 (다른 프로젝트)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.core; <span style="color:#75715e">// 같은 패키지명 사용</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Hacker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">access</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> InternalClass();  <span style="color:#75715e">// package-private인데 접근됨</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>패키지는 <strong>코드 조직화 수단</strong>일 뿐, 실제 캡슐화는 <strong>컴파일/배포 단위인 모듈</strong>에서 이루어져야 합니다.</p>
<h3 id="2-모듈이-진짜-경계다">2. 모듈이 진짜 경계다<a hidden class="anchor" aria-hidden="true" href="#2-모듈이-진짜-경계다">#</a></h3>
<pre tabindex="0"><code>┌─────────────────────────┐
│  core.jar (모듈)         │ ← 배포 단위
│                         │
│  internal class 계산기    │ ← 모듈 내부만
│  public class API       │ ← 외부 노출
└─────────────────────────┘
</code></pre><p>JAR 파일이 실제 경계이며, internal은 이 현실을 반영합니다.</p>
<h3 id="3-테스트-친화적-설계">3. 테스트 친화적 설계<a hidden class="anchor" aria-hidden="true" href="#3-테스트-친화적-설계">#</a></h3>
<pre tabindex="0"><code>module-core/ (하나의 모듈)
├── src/main/kotlin/   ← internal 정의
└── src/test/kotlin/   ← internal 접근 가능
</code></pre><p>main과 test는 같은 모듈이므로 internal 클래스에 자연스럽게 접근 가능합니다.</p>
<p>반면 Java는 같은 모듈이라도 package-private 클래스를 다른 패키지의 테스트에서 접근하려면 public으로 변경하거나 같은 패키지에 테스트를 작성해야 합니다.</p>
<h2 id="java-kotlin-혼용-시-테스트-코드-문제">Java-Kotlin 혼용 시 테스트 코드 문제<a hidden class="anchor" aria-hidden="true" href="#java-kotlin-혼용-시-테스트-코드-문제">#</a></h2>
<h3 id="문제-상황">문제 상황<a hidden class="anchor" aria-hidden="true" href="#문제-상황">#</a></h3>
<h4 id="케이스-1-기본-생성자-정상-동작">케이스 1: 기본 생성자 (정상 동작)<a hidden class="anchor" aria-hidden="true" href="#케이스-1-기본-생성자-정상-동작">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Java: src/main/java/com/example/Calculator.java</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculator</span> {  <span style="color:#75715e">// package-private</span>
</span></span><span style="display:flex;"><span>    Calculator() {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// Kotlin: src/test/kotlin/com/example/CalculatorTest.kt
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CalculatorTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> calc = Calculator()  <span style="color:#75715e">// 정상 동작
</span></span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="케이스-2-파라미터-생성자-문제-발생">케이스 2: 파라미터 생성자 (문제 발생)<a hidden class="anchor" aria-hidden="true" href="#케이스-2-파라미터-생성자-문제-발생">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Java: private 필드 + package-private 생성자</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> BigDecimal value;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Calculator() {}  <span style="color:#75715e">// 기본 생성자</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Calculator(BigDecimal value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// Kotlin 테스트
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CalculatorTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// IllegalAccessError 발생
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> calc = Calculator(<span style="color:#a6e22e">BigDecimal</span>.ONE)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Reflection으로 우회 (기본 생성자 사용)
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> calc = Calculator<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java
</span></span><span style="display:flex;"><span>            .getDeclaredConstructor()
</span></span><span style="display:flex;"><span>            .newInstance()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> field = Calculator<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java
</span></span><span style="display:flex;"><span>            .getDeclaredField(<span style="color:#e6db74">&#34;value&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">field</span>.isAccessible = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">field</span>.<span style="color:#66d9ef">set</span>(calc, <span style="color:#a6e22e">BigDecimal</span>.ONE)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="원인-분석">원인 분석<a hidden class="anchor" aria-hidden="true" href="#원인-분석">#</a></h4>
<p>JVM 바이트코드 레벨에서 package-private은 접근 제어 플래그가 없는 특수한 상태:</p>
<ul>
<li><code>ACC_PUBLIC</code> (0x0001)</li>
<li><code>ACC_PRIVATE</code> (0x0002)</li>
<li>플래그 없음 = package-private</li>
</ul>
<p><strong>private 필드 + package-private 생성자</strong> 조합에서 Kotlin 컴파일러가 이를 제대로 처리하지 못합니다.</p>
<h3 id="해결-방법">해결 방법<a hidden class="anchor" aria-hidden="true" href="#해결-방법">#</a></h3>
<h4 id="1-java로-테스트-작성">1. Java로 테스트 작성<a hidden class="anchor" aria-hidden="true" href="#1-java로-테스트-작성">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// src/test/java/로 테스트 이동 (가장 확실)</span>
</span></span></code></pre></div><h4 id="2-public-생성자로-변경">2. public 생성자로 변경<a hidden class="anchor" aria-hidden="true" href="#2-public-생성자로-변경">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Calculator</span>(BigDecimal value) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-테스트용-factory-메서드">3. 테스트용 Factory 메서드<a hidden class="anchor" aria-hidden="true" href="#3-테스트용-factory-메서드">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 테스트를 위한 static 메서드</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Calculator <span style="color:#a6e22e">createForTest</span>(BigDecimal value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Calculator(value);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-kotlin으로-완전-마이그레이션">4. Kotlin으로 완전 마이그레이션<a hidden class="anchor" aria-hidden="true" href="#4-kotlin으로-완전-마이그레이션">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculator</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> value: BigDecimal
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><h2 id="kotlin-접근-제어자-설계의-트레이드오프">Kotlin 접근 제어자 설계의 트레이드오프<a hidden class="anchor" aria-hidden="true" href="#kotlin-접근-제어자-설계의-트레이드오프">#</a></h2>
<h3 id="얻은-것">얻은 것<a hidden class="anchor" aria-hidden="true" href="#얻은-것">#</a></h3>
<ul>
<li>명확한 모듈 경계</li>
<li>테스트 접근 용이</li>
<li>단순한 접근 제어자</li>
</ul>
<h3 id="잃은-것">잃은 것<a hidden class="anchor" aria-hidden="true" href="#잃은-것">#</a></h3>
<ul>
<li>패키지 단위 세밀한 캡슐화</li>
<li>같은 모듈 내 자동완성 노이즈</li>
<li>기존 Java 구조와의 호환성</li>
</ul>
<h3 id="권장-프로젝트-구조">권장 프로젝트 구조<a hidden class="anchor" aria-hidden="true" href="#권장-프로젝트-구조">#</a></h3>
<pre tabindex="0"><code>project/
├── module-api/       ← 외부 노출
├── module-domain/    ← 도메인 로직
├── module-core/      ← 핵심 로직
└── module-infra/     ← 인프라
</code></pre><p>캡슐화가 필요하면 패키지가 아닌 모듈로 분리합니다.</p>
<h3 id="모듈-크기-선택">모듈 크기 선택<a hidden class="anchor" aria-hidden="true" href="#모듈-크기-선택">#</a></h3>
<table>
  <thead>
      <tr>
          <th>크기</th>
          <th>장점</th>
          <th>단점</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>작게 많이</td>
          <td>캡슐화 명확</td>
          <td>설정 복잡</td>
      </tr>
      <tr>
          <td>크게 적게</td>
          <td>단순함</td>
          <td>internal 노출 범위 넓음</td>
      </tr>
  </tbody>
</table>
<h2 id="정리">정리<a hidden class="anchor" aria-hidden="true" href="#정리">#</a></h2>
<p>Kotlin은 패키지를 조직화 수단으로, 모듈을 캡슐화 경계로 봅니다. 이는 현대적인 빌드 시스템과 멀티모듈 구조에 더 적합한 설계입니다.</p>
<p>하지만 Java와 혼용 시:</p>
<ul>
<li>package-private 처리에 주의 필요</li>
<li>protected 의미가 다름을 인지</li>
<li>테스트 코드 작성 시 제약 발생 가능</li>
</ul>
<p>마이그레이션 전략:</p>
<ol>
<li>기존 Java는 package-private 유지</li>
<li>신규 모듈은 Kotlin + internal</li>
<li>필요시 모듈 분리</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dont.kr/tags/kotlin/">Kotlin</a></li>
      <li><a href="https://dont.kr/tags/access-modifier/">Access Modifier</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
    data-repo="duddns/dontkr-www"
    data-repo-id="R_kgDOJ5uOLg"
    data-category="General"
    data-category-id="DIC_kwDOJ5uOLs4CzVRe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="ko"
    crossorigin="anonymous"
    async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://dont.kr/">DoNT - Do Not Think!!!</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
