<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL vs Oracle: 커서(Cursor) 동작 방식 비교 | DoNT - Do Not Think!!!</title>
<meta name="keywords" content="db, cursor, mysql, oracle">
<meta name="description" content="TL;DR

MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름
MySQL: 임시 테이블 생성하여 전체 결과 저장
Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치
&ldquo;클라이언트 사이드 커서&quot;는 MySQL에서 공식 용어가 아님
MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공


1. 커서란 무엇인가
데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.
데이터베이스에서는 결과를 처리하는 위치에 따라 서버 커서와 클라이언트 커서으로 구분할 수 있습니다.">
<meta name="author" content="">
<link rel="canonical" href="https://dont.kr/posts/2025/2025-11-04-database-cursor-mysql-vs-oracle/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f56f6fcbbbf1b56135b161970b2be054c0f93cd0507af71fddbab4cf707c5c56.css" integrity="sha256-9W9vy7vxtWE1sWGXCyvgVMD5PNBQevcf3bq0z3B8XFY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dont.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dont.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dont.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dont.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://dont.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://dont.kr/posts/2025/2025-11-04-database-cursor-mysql-vs-oracle/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVEM176XM1"></script>
      <script>
        var doNotTrack = false;
        if ( true ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZVEM176XM1');
        }
      </script><meta property="og:url" content="https://dont.kr/posts/2025/2025-11-04-database-cursor-mysql-vs-oracle/">
  <meta property="og:site_name" content="DoNT - Do Not Think!!!">
  <meta property="og:title" content="MySQL vs Oracle: 커서(Cursor) 동작 방식 비교">
  <meta property="og:description" content="TL;DR MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름 MySQL: 임시 테이블 생성하여 전체 결과 저장 Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치 “클라이언트 사이드 커서&#34;는 MySQL에서 공식 용어가 아님 MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공 1. 커서란 무엇인가 데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.
데이터베이스에서는 결과를 처리하는 위치에 따라 서버 커서와 클라이언트 커서으로 구분할 수 있습니다.">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-04T00:00:00+09:00">
    <meta property="article:modified_time" content="2025-11-04T00:00:00+09:00">
    <meta property="article:tag" content="Db">
    <meta property="article:tag" content="Cursor">
    <meta property="article:tag" content="Mysql">
    <meta property="article:tag" content="Oracle">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL vs Oracle: 커서(Cursor) 동작 방식 비교">
<meta name="twitter:description" content="TL;DR

MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름
MySQL: 임시 테이블 생성하여 전체 결과 저장
Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치
&ldquo;클라이언트 사이드 커서&quot;는 MySQL에서 공식 용어가 아님
MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공


1. 커서란 무엇인가
데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.
데이터베이스에서는 결과를 처리하는 위치에 따라 서버 커서와 클라이언트 커서으로 구분할 수 있습니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dont.kr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MySQL vs Oracle: 커서(Cursor) 동작 방식 비교",
      "item": "https://dont.kr/posts/2025/2025-11-04-database-cursor-mysql-vs-oracle/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL vs Oracle: 커서(Cursor) 동작 방식 비교",
  "name": "MySQL vs Oracle: 커서(Cursor) 동작 방식 비교",
  "description": "TL;DR MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름 MySQL: 임시 테이블 생성하여 전체 결과 저장 Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치 \u0026ldquo;클라이언트 사이드 커서\u0026quot;는 MySQL에서 공식 용어가 아님 MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공 1. 커서란 무엇인가 데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.\n데이터베이스에서는 결과를 처리하는 위치에 따라 서버 커서와 클라이언트 커서으로 구분할 수 있습니다.\n",
  "keywords": [
    "db", "cursor", "mysql", "oracle"
  ],
  "articleBody": "TL;DR MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름 MySQL: 임시 테이블 생성하여 전체 결과 저장 Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치 “클라이언트 사이드 커서\"는 MySQL에서 공식 용어가 아님 MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공 1. 커서란 무엇인가 데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.\n데이터베이스에서는 결과를 처리하는 위치에 따라 서버 커서와 클라이언트 커서으로 구분할 수 있습니다.\n커서의 필요성 -- 100만 건의 데이터를 한 번에 처리? SELECT * FROM large_table; -- 메모리 부족! -- 커서를 사용하면? -- 필요한 만큼만 순차적으로 처리 가능 2. 하지만 혼란스러운 “클라이언트 커서” 일반적인 데이터베이스 용어 SQL Server, PostgreSQL 등 많은 데이터베이스에서는 “클라이언트 사이드 커서(Client-side Cursor)“라는 용어를 공식적으로 사용합니다. 이는 전체 결과를 클라이언트 메모리로 가져와서 클라이언트 측에서 커서를 관리하는 방식을 의미합니다.\nMySQL에서는 부적절한 이유 MySQL 공식 문서는 “클라이언트 사이드 커서\"라는 용어를 사용하지 않습니다. 대신 MySQL은 결과 처리 방식을 다음과 같이 구분합니다:\n클라이언트 버퍼링 (mysql_store_result()) 전체 결과를 클라이언트 메모리로 한 번에 로드 장점: 빠른 순회, 역방향 이동 가능 단점: 대용량 데이터 시 메모리 부족 스트리밍 (mysql_use_result()) 서버에서 결과를 연속으로 전송, 클라이언트가 순차 처리 장점: 메모리 효율적 단점: 한 방향만 가능, 연결 유지 필요 서버 커서 (Server-side Cursor) 서버에 커서 상태 유지, 필요한 만큼만 전송 장점: 메모리 효율적, 유연한 페치 단점: 서버 리소스 사용, 설정 필요 MySQL 문맥에서 “클라이언트 커서\"라고 표현하면 혼란을 줄 수 있습니다. 실제로는 단순히 전체 결과를 클라이언트 메모리에 로드하는 것일 뿐, 진짜 “커서\"가 아니기 때문입니다.\n올바른 용어 사용 환경 적절한 표현 MySQL 전문가와 대화 “클라이언트 버퍼링”, “전체 결과 로드” 일반 DB 개발자와 대화 “클라이언트 사이드 커서” (통용됨) 기술 문서 작성 “클라이언트 측 결과 버퍼링” 권장: MySQL 관련 글에서는 “클라이언트 버퍼링\"이 더 정확합니다. 3. MySQL 서버 커서 3.1 SQL 콘솔에서 MySQL 콘솔에서는 Stored Procedure 내부에서만 커서를 사용할 수 있습니다.\n3.2 클라이언트 라이브러리에서 (JDBC) JDBC를 통해서는 일반 SELECT 쿼리에도 서버 커서를 사용할 수 있습니다.\nString url = \"jdbc:mysql://localhost:3306/db?useCursorFetch=true\"; PreparedStatement pstmt = conn.prepareStatement( \"SELECT * FROM employees\", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY ); pstmt.setFetchSize(100); ResultSet rs = pstmt.executeQuery(); 필수 조건:\nuseCursorFetch=true (JDBC URL 파라미터) setFetchSize(n \u003e 0) 설정 3.3 내부 동작: 임시 테이블 방식 MySQL의 서버 커서는 내부 임시 테이블로 구현됩니다.\n쿼리 실행 ↓ 전체 결과를 임시 테이블에 저장 - MEMORY 테이블 (작은 경우) - MyISAM 테이블 (큰 경우, max_heap_table_size 초과 시) ↓ 클라이언트 요청 시 fetchSize만큼 전송 특징:\n전체 결과가 임시 테이블에 구체화됨 초기 구체화 시간이 필요함 대용량 결과 시 디스크 사용 가능 메모리 효율성이 상대적으로 낮음 4. Oracle 서버 커서 4.1 SQL 콘솔에서 Oracle은 SQL 콘솔에서 직접 커서를 사용할 수 있습니다. 이때 모든 SQL 문이 자동으로 암시적 커서를 사용합니다.\n4.2 클라이언트 라이브러리에서 (JDBC) Oracle JDBC는 setFetchSize()만으로 서버 커서가 활성화됩니다.\nString url = \"jdbc:oracle:thin:@localhost:1521:orcl\"; PreparedStatement pstmt = conn.prepareStatement( \"SELECT * FROM employees\" ); pstmt.setFetchSize(100); ResultSet rs = pstmt.executeQuery(); 필수 조건:\nsetFetchSize(n \u003e 0) (이것만 필요) 4.3 내부 동작: PGA 메모리 방식 Oracle은 PGA(Program Global Area) 메모리에서 커서 상태를 유지합니다.\n쿼리 실행 ↓ 결과 집합 포인터를 PGA에 생성 (실제 데이터는 Buffer Cache에 유지) ↓ 클라이언트 요청 시 필요한 행만 전송 특징:\n임시 테이블을 생성하지 않음 전체 결과를 미리 구체화하지 않음 세션별 PGA 사용으로 격리됨 메모리 효율적 On-demand 페치로 성능 우수 5. MySQL vs Oracle 비교 사용 방법 SQL 콘솔\nMySQL: Stored Procedure 내부에서만 가능 Oracle: PL/SQL 블록에서 직접 사용 가능, 암시적 커서 자동 적용 JDBC 설정\nMySQL: useCursorFetch=true + setFetchSize(n \u003e 0) 필수 Oracle: setFetchSize(n \u003e 0) 만 필요 내부 동작 방식 동작 방식\nMySQL: 쿼리 실행 시 전체 결과를 임시 테이블에 저장 (MEMORY → MyISAM → 디스크, 초기 오버헤드 높음) Oracle: 세션별 PGA에 커서 상태만 유지, 필요한 만큼 On-demand 페치 (즉시 시작) 성능 특성 MySQL 서버 커서\n전체 결과를 미리 저장하므로 초기 대기 시간 발생 메모리/디스크 사용량이 높지만 결과 일관성 보장 작은 결과 집합이나 여러 번 순회가 필요한 경우 적합 Oracle 서버 커서\n필요한 만큼만 페치하므로 즉시 시작 가능 메모리 효율적이지만 세션 상태 관리 필요 대용량 결과 집합이나 스트리밍 처리에 적합 6. 다른 데이터베이스는? PostgreSQL Oracle과 유사한 방식으로 서버 커서를 지원합니다.\nSQL 콘솔에서 DECLARE CURSOR 사용 가능 FETCH 방향 제어 가능 (FORWARD, BACKWARD) 트랜잭션 내에서만 유효 SQL Server 클라이언트/서버 사이드 커서를 모두 명시적으로 구분하여 지원합니다.\nADO에서 CursorLocation 속성으로 선택 adUseClient: 클라이언트 사이드 커서 adUseServer: 서버 사이드 커서 성능상 커서보다 SET 기반 처리 권장 참고 문서 MySQL MySQL Connector/J - Result Set Implementation MySQL Connector/J - Performance Extensions MySQL Server - Cursors Oracle Oracle JDBC Developer’s Guide - Result Set Oracle PL/SQL Language Reference - Cursors Oracle Database Concepts - Memory Architecture ",
  "wordCount" : "722",
  "inLanguage": "ko",
  "datePublished": "2025-11-04T00:00:00+09:00",
  "dateModified": "2025-11-04T00:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dont.kr/posts/2025/2025-11-04-database-cursor-mysql-vs-oracle/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DoNT - Do Not Think!!!",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dont.kr/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dont.kr/" accesskey="h" title="DoNT - Do Not Think!!! (Alt + H)">DoNT - Do Not Think!!!</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dont.kr/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dont.kr/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      MySQL vs Oracle: 커서(Cursor) 동작 방식 비교
    </h1>
    <div class="post-meta"><span title='2025-11-04 00:00:00 +0900 KST'>2025년 11월 4일</span>

</div>
  </header> 
  <div class="post-content"><h2 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<ul>
<li>MySQL과 Oracle은 서버 커서 구현 방식이 근본적으로 다름</li>
<li>MySQL: 임시 테이블 생성하여 전체 결과 저장</li>
<li>Oracle: PGA 메모리에서 커서 상태만 유지하고 필요한 만큼 페치</li>
<li>&ldquo;클라이언트 사이드 커서&quot;는 MySQL에서 공식 용어가 아님</li>
<li>MySQL: 클라이언트 버퍼링, 스트리밍, 서버 커서 3가지 방식 제공</li>
</ul>
<hr>
<h2 id="1-커서란-무엇인가">1. 커서란 무엇인가<a hidden class="anchor" aria-hidden="true" href="#1-커서란-무엇인가">#</a></h2>
<p>데이터베이스 커서는 쿼리 결과를 순차적으로 처리하기 위한 메커니즘입니다. 대용량 결과를 한 번에 메모리로 로드하지 않고, 필요한 만큼만 가져와서 처리할 수 있게 해줍니다.</p>
<p>데이터베이스에서는 결과를 처리하는 위치에 따라 <strong>서버 커서</strong>와 <strong>클라이언트 커서</strong>으로 구분할 수 있습니다.</p>
<h3 id="커서의-필요성">커서의 필요성<a hidden class="anchor" aria-hidden="true" href="#커서의-필요성">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 100만 건의 데이터를 한 번에 처리?
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> large_table; <span style="color:#75715e">-- 메모리 부족!
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 커서를 사용하면?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- 필요한 만큼만 순차적으로 처리 가능
</span></span></span></code></pre></div><hr>
<h2 id="2-하지만-혼란스러운-클라이언트-커서">2. 하지만 혼란스러운 &ldquo;클라이언트 커서&rdquo;<a hidden class="anchor" aria-hidden="true" href="#2-하지만-혼란스러운-클라이언트-커서">#</a></h2>
<h3 id="일반적인-데이터베이스-용어">일반적인 데이터베이스 용어<a hidden class="anchor" aria-hidden="true" href="#일반적인-데이터베이스-용어">#</a></h3>
<p>SQL Server, PostgreSQL 등 많은 데이터베이스에서는 &ldquo;클라이언트 사이드 커서(Client-side Cursor)&ldquo;라는 용어를 공식적으로 사용합니다. 이는 전체 결과를 클라이언트 메모리로 가져와서 클라이언트 측에서 커서를 관리하는 방식을 의미합니다.</p>
<h3 id="mysql에서는-부적절한-이유">MySQL에서는 부적절한 이유<a hidden class="anchor" aria-hidden="true" href="#mysql에서는-부적절한-이유">#</a></h3>
<p>MySQL 공식 문서는 &ldquo;클라이언트 사이드 커서&quot;라는 용어를 사용하지 않습니다. 대신 MySQL은 결과 처리 방식을 다음과 같이 구분합니다:</p>
<ul>
<li><strong>클라이언트 버퍼링</strong> (<code>mysql_store_result()</code>)
<ul>
<li>전체 결과를 클라이언트 메모리로 한 번에 로드</li>
<li>장점: 빠른 순회, 역방향 이동 가능</li>
<li>단점: 대용량 데이터 시 메모리 부족</li>
</ul>
</li>
<li><strong>스트리밍</strong> (<code>mysql_use_result()</code>)
<ul>
<li>서버에서 결과를 연속으로 전송, 클라이언트가 순차 처리</li>
<li>장점: 메모리 효율적</li>
<li>단점: 한 방향만 가능, 연결 유지 필요</li>
</ul>
</li>
<li><strong>서버 커서</strong> (Server-side Cursor)
<ul>
<li>서버에 커서 상태 유지, 필요한 만큼만 전송</li>
<li>장점: 메모리 효율적, 유연한 페치</li>
<li>단점: 서버 리소스 사용, 설정 필요</li>
</ul>
</li>
</ul>
<p>MySQL 문맥에서 &ldquo;클라이언트 커서&quot;라고 표현하면 혼란을 줄 수 있습니다. 실제로는 단순히 전체 결과를 클라이언트 메모리에 로드하는 것일 뿐, 진짜 &ldquo;커서&quot;가 아니기 때문입니다.</p>
<h3 id="올바른-용어-사용">올바른 용어 사용<a hidden class="anchor" aria-hidden="true" href="#올바른-용어-사용">#</a></h3>
<table>
  <thead>
      <tr>
          <th>환경</th>
          <th>적절한 표현</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>MySQL 전문가와 대화</td>
          <td>&ldquo;클라이언트 버퍼링&rdquo;, &ldquo;전체 결과 로드&rdquo;</td>
      </tr>
      <tr>
          <td>일반 DB 개발자와 대화</td>
          <td>&ldquo;클라이언트 사이드 커서&rdquo; (통용됨)</td>
      </tr>
      <tr>
          <td>기술 문서 작성</td>
          <td>&ldquo;클라이언트 측 결과 버퍼링&rdquo;</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>권장</strong>: MySQL 관련 글에서는 &ldquo;클라이언트 버퍼링&quot;이 더 정확합니다.</li>
</ul>
<hr>
<h2 id="3-mysql-서버-커서">3. MySQL 서버 커서<a hidden class="anchor" aria-hidden="true" href="#3-mysql-서버-커서">#</a></h2>
<h3 id="31-sql-콘솔에서">3.1 SQL 콘솔에서<a hidden class="anchor" aria-hidden="true" href="#31-sql-콘솔에서">#</a></h3>
<p>MySQL 콘솔에서는 Stored Procedure 내부에서만 커서를 사용할 수 있습니다.</p>
<h3 id="32-클라이언트-라이브러리에서-jdbc">3.2 클라이언트 라이브러리에서 (JDBC)<a hidden class="anchor" aria-hidden="true" href="#32-클라이언트-라이브러리에서-jdbc">#</a></h3>
<p>JDBC를 통해서는 일반 SELECT 쿼리에도 서버 커서를 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;jdbc:mysql://localhost:3306/db?useCursorFetch=true&#34;</span>;
</span></span><span style="display:flex;"><span>PreparedStatement pstmt <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">prepareStatement</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;SELECT * FROM employees&#34;</span>,
</span></span><span style="display:flex;"><span>    ResultSet.<span style="color:#a6e22e">TYPE_FORWARD_ONLY</span>,
</span></span><span style="display:flex;"><span>    ResultSet.<span style="color:#a6e22e">CONCUR_READ_ONLY</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>pstmt.<span style="color:#a6e22e">setFetchSize</span>(100);
</span></span><span style="display:flex;"><span>ResultSet rs <span style="color:#f92672">=</span> pstmt.<span style="color:#a6e22e">executeQuery</span>();
</span></span></code></pre></div><p><strong>필수 조건</strong>:</p>
<ol>
<li><code>useCursorFetch=true</code> (JDBC URL 파라미터)</li>
<li><code>setFetchSize(n &gt; 0)</code> 설정</li>
</ol>
<h3 id="33-내부-동작-임시-테이블-방식">3.3 내부 동작: 임시 테이블 방식<a hidden class="anchor" aria-hidden="true" href="#33-내부-동작-임시-테이블-방식">#</a></h3>
<p>MySQL의 서버 커서는 내부 임시 테이블로 구현됩니다.</p>
<pre tabindex="0"><code>쿼리 실행
    ↓
전체 결과를 임시 테이블에 저장
- MEMORY 테이블 (작은 경우)
- MyISAM 테이블 (큰 경우, max_heap_table_size 초과 시)
    ↓
클라이언트 요청 시 fetchSize만큼 전송
</code></pre><p><strong>특징</strong>:</p>
<ul>
<li>전체 결과가 임시 테이블에 구체화됨</li>
<li>초기 구체화 시간이 필요함</li>
<li>대용량 결과 시 디스크 사용 가능</li>
<li>메모리 효율성이 상대적으로 낮음</li>
</ul>
<hr>
<h2 id="4-oracle-서버-커서">4. Oracle 서버 커서<a hidden class="anchor" aria-hidden="true" href="#4-oracle-서버-커서">#</a></h2>
<h3 id="41-sql-콘솔에서">4.1 SQL 콘솔에서<a hidden class="anchor" aria-hidden="true" href="#41-sql-콘솔에서">#</a></h3>
<p>Oracle은 SQL 콘솔에서 직접 커서를 사용할 수 있습니다. 이때 모든 SQL 문이 자동으로 암시적 커서를 사용합니다.</p>
<h3 id="42-클라이언트-라이브러리에서-jdbc">4.2 클라이언트 라이브러리에서 (JDBC)<a hidden class="anchor" aria-hidden="true" href="#42-클라이언트-라이브러리에서-jdbc">#</a></h3>
<p>Oracle JDBC는 <strong><code>setFetchSize()</code>만으로</strong> 서버 커서가 활성화됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;jdbc:oracle:thin:@localhost:1521:orcl&#34;</span>;
</span></span><span style="display:flex;"><span>PreparedStatement pstmt <span style="color:#f92672">=</span> conn.<span style="color:#a6e22e">prepareStatement</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;SELECT * FROM employees&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>pstmt.<span style="color:#a6e22e">setFetchSize</span>(100);
</span></span><span style="display:flex;"><span>ResultSet rs <span style="color:#f92672">=</span> pstmt.<span style="color:#a6e22e">executeQuery</span>();
</span></span></code></pre></div><p><strong>필수 조건</strong>:</p>
<ol>
<li><code>setFetchSize(n &gt; 0)</code> (이것만 필요)</li>
</ol>
<h3 id="43-내부-동작-pga-메모리-방식">4.3 내부 동작: PGA 메모리 방식<a hidden class="anchor" aria-hidden="true" href="#43-내부-동작-pga-메모리-방식">#</a></h3>
<p>Oracle은 PGA(Program Global Area) 메모리에서 커서 상태를 유지합니다.</p>
<pre tabindex="0"><code>쿼리 실행
    ↓
결과 집합 포인터를 PGA에 생성
(실제 데이터는 Buffer Cache에 유지)
    ↓
클라이언트 요청 시 필요한 행만 전송
</code></pre><p><strong>특징</strong>:</p>
<ul>
<li>임시 테이블을 생성하지 않음</li>
<li>전체 결과를 미리 구체화하지 않음</li>
<li>세션별 PGA 사용으로 격리됨</li>
<li>메모리 효율적</li>
<li>On-demand 페치로 성능 우수</li>
</ul>
<hr>
<h2 id="5-mysql-vs-oracle-비교">5. MySQL vs Oracle 비교<a hidden class="anchor" aria-hidden="true" href="#5-mysql-vs-oracle-비교">#</a></h2>
<h3 id="사용-방법">사용 방법<a hidden class="anchor" aria-hidden="true" href="#사용-방법">#</a></h3>
<p><strong>SQL 콘솔</strong></p>
<ul>
<li><strong>MySQL</strong>: Stored Procedure 내부에서만 가능</li>
<li><strong>Oracle</strong>: PL/SQL 블록에서 직접 사용 가능, 암시적 커서 자동 적용</li>
</ul>
<p><strong>JDBC 설정</strong></p>
<ul>
<li><strong>MySQL</strong>: <code>useCursorFetch=true</code> + <code>setFetchSize(n &gt; 0)</code> 필수</li>
<li><strong>Oracle</strong>: <code>setFetchSize(n &gt; 0)</code> 만 필요</li>
</ul>
<h3 id="내부-동작-방식">내부 동작 방식<a hidden class="anchor" aria-hidden="true" href="#내부-동작-방식">#</a></h3>
<p><strong>동작 방식</strong></p>
<ul>
<li><strong>MySQL</strong>: 쿼리 실행 시 전체 결과를 임시 테이블에 저장 (MEMORY → MyISAM → 디스크, 초기 오버헤드 높음)</li>
<li><strong>Oracle</strong>: 세션별 PGA에 커서 상태만 유지, 필요한 만큼 On-demand 페치 (즉시 시작)</li>
</ul>
<h3 id="성능-특성">성능 특성<a hidden class="anchor" aria-hidden="true" href="#성능-특성">#</a></h3>
<p><strong>MySQL 서버 커서</strong></p>
<ul>
<li>전체 결과를 미리 저장하므로 초기 대기 시간 발생</li>
<li>메모리/디스크 사용량이 높지만 결과 일관성 보장</li>
<li>작은 결과 집합이나 여러 번 순회가 필요한 경우 적합</li>
</ul>
<p><strong>Oracle 서버 커서</strong></p>
<ul>
<li>필요한 만큼만 페치하므로 즉시 시작 가능</li>
<li>메모리 효율적이지만 세션 상태 관리 필요</li>
<li>대용량 결과 집합이나 스트리밍 처리에 적합</li>
</ul>
<hr>
<h2 id="6-다른-데이터베이스는">6. 다른 데이터베이스는?<a hidden class="anchor" aria-hidden="true" href="#6-다른-데이터베이스는">#</a></h2>
<h3 id="postgresql">PostgreSQL<a hidden class="anchor" aria-hidden="true" href="#postgresql">#</a></h3>
<p>Oracle과 유사한 방식으로 서버 커서를 지원합니다.</p>
<ul>
<li>SQL 콘솔에서 <code>DECLARE CURSOR</code> 사용 가능</li>
<li><code>FETCH</code> 방향 제어 가능 (FORWARD, BACKWARD)</li>
<li>트랜잭션 내에서만 유효</li>
</ul>
<h3 id="sql-server">SQL Server<a hidden class="anchor" aria-hidden="true" href="#sql-server">#</a></h3>
<p>클라이언트/서버 사이드 커서를 모두 명시적으로 구분하여 지원합니다.</p>
<ul>
<li>ADO에서 <code>CursorLocation</code> 속성으로 선택</li>
<li><code>adUseClient</code>: 클라이언트 사이드 커서</li>
<li><code>adUseServer</code>: 서버 사이드 커서</li>
<li>성능상 커서보다 SET 기반 처리 권장</li>
</ul>
<hr>
<h2 id="참고-문서">참고 문서<a hidden class="anchor" aria-hidden="true" href="#참고-문서">#</a></h2>
<h3 id="mysql">MySQL<a hidden class="anchor" aria-hidden="true" href="#mysql">#</a></h3>
<ul>
<li><a href="https://dev.mysql.com/doc/connector-j/en/connector-j-reference-implementation-notes.html">MySQL Connector/J - Result Set Implementation</a></li>
<li><a href="https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-performance-extensions.html">MySQL Connector/J - Performance Extensions</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/cursors.html">MySQL Server - Cursors</a></li>
</ul>
<h3 id="oracle">Oracle<a hidden class="anchor" aria-hidden="true" href="#oracle">#</a></h3>
<ul>
<li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/jjdbc/Oracle-JDBC-result-set.html">Oracle JDBC Developer&rsquo;s Guide - Result Set</a></li>
<li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/lnpls/static-sql.html#GUID-89B4B825-3D56-40A9-9D3C-C60CF24D7B0E">Oracle PL/SQL Language Reference - Cursors</a></li>
<li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/memory-architecture.html">Oracle Database Concepts - Memory Architecture</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dont.kr/tags/db/">Db</a></li>
      <li><a href="https://dont.kr/tags/cursor/">Cursor</a></li>
      <li><a href="https://dont.kr/tags/mysql/">Mysql</a></li>
      <li><a href="https://dont.kr/tags/oracle/">Oracle</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
    data-repo="duddns/dontkr-www"
    data-repo-id="R_kgDOJ5uOLg"
    data-category="General"
    data-category-id="DIC_kwDOJ5uOLs4CzVRe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="ko"
    crossorigin="anonymous"
    async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://dont.kr/">DoNT - Do Not Think!!!</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
