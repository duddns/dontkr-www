<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Apache Kafka 기본 개념 정리 | DoNT - Do Not Think!!!</title>
<meta name="keywords" content="kafka, message queue">
<meta name="description" content="Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.
아키텍처
Kafka Cluster (여러 Broker의 집합)
    │
    └─ Broker (카프카 서버, 여러 대 가능)
           │
           └─ Topic (메시지 종류)
                  │
                  ├─ Partition 0 ──┐
                  ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1
                  └─ Partition 2 ──┘                     ├─ Consumer 2
                          │                              └─ Consumer 3
                          │
                          └──────────── Consumer Group B ─── Consumer 1
구성 요소

Broker: Kafka 서버 (여러 대로 클러스터 구성)
Topic: 메시지 종류별 논리적 그룹
Partition: 토픽 내 병렬 처리 단위
Consumer Group: 동일 group.id로 묶인 컨슈머들

설계 시 고려사항

파티션 수 = 최대 병렬 처리 수
파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle)

용어 정리  ← 여기

  
      
          동작
          일반 메시지 큐
          Kafka
      
  
  
      
          메시지 보내기
          Publish
          Produce
      
      
          보내는 주체
          Publisher
          Producer
      
      
          토픽 구독
          Subscribe
          Subscribe (동일)
      
      
          메시지 받기
          Push (서버가 보냄)
          Poll (주기적으로 가져감)
      
      
          받는 주체
          Subscriber
          Consumer
      
  

메시지 흐름
Producer ──produce──▶ Kafka Broker ◀──poll── Consumer
                                                  │
                                                  ▼
                                              consume
                                              처리 로직
동작 방식

Producer가 메시지 전송
Broker가 파티션에 메시지 저장
Consumer가 주기적으로 폴링
새 메시지 있으면 가져와서 처리

메시지 관리
Offset 관리

Offset: 파티션 내 메시지 위치 (0부터 시작)
Committed Offset: 처리 완료한 마지막 위치
Latest Offset: 파티션의 마지막 메시지 위치
Consumer Lag: Latest - Committed (처리 지연 정도)

Commit 전략
// 자동 커밋 (기본값)
enable.auto.commit=true
auto.commit.interval.ms=5000

// 수동 커밋
consumer.commitSync();
consumer.commitAsync();
메시지 전달 보장
1. At-most-once

처리 전 commit
장점: 중복 없음
단점: 메시지 유실 가능

2. At-least-once (기본값)

처리 후 commit
장점: 메시지 유실 없음
단점: 중복 처리 가능
중요: 애플리케이션 레벨에서 멱등성 보장 필요

3. Exactly-once

트랜잭션 사용
장점: 중복도 유실도 없음
단점: 성능 오버헤드

메시지 보관
일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:">
<meta name="author" content="">
<link rel="canonical" href="https://dont.kr/posts/2025/2025-11-27-apache-kafka/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4bef824c135d95ffd8df119b1b511d3c1507c4d3fed7cf470539d03f95ec7625.css" integrity="sha256-S&#43;&#43;CTBNdlf/Y3xGbG1EdPBUHxNP&#43;189HBTnQP5XsdiU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dont.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dont.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dont.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dont.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://dont.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://dont.kr/posts/2025/2025-11-27-apache-kafka/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://dont.kr/posts/2025/2025-11-27-apache-kafka/">
  <meta property="og:site_name" content="DoNT - Do Not Think!!!">
  <meta property="og:title" content="Apache Kafka 기본 개념 정리">
  <meta property="og:description" content="Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.
아키텍처 Kafka Cluster (여러 Broker의 집합) │ └─ Broker (카프카 서버, 여러 대 가능) │ └─ Topic (메시지 종류) │ ├─ Partition 0 ──┐ ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1 └─ Partition 2 ──┘ ├─ Consumer 2 │ └─ Consumer 3 │ └──────────── Consumer Group B ─── Consumer 1 구성 요소 Broker: Kafka 서버 (여러 대로 클러스터 구성) Topic: 메시지 종류별 논리적 그룹 Partition: 토픽 내 병렬 처리 단위 Consumer Group: 동일 group.id로 묶인 컨슈머들 설계 시 고려사항 파티션 수 = 최대 병렬 처리 수 파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle) 용어 정리 ← 여기 동작 일반 메시지 큐 Kafka 메시지 보내기 Publish Produce 보내는 주체 Publisher Producer 토픽 구독 Subscribe Subscribe (동일) 메시지 받기 Push (서버가 보냄) Poll (주기적으로 가져감) 받는 주체 Subscriber Consumer 메시지 흐름 Producer ──produce──▶ Kafka Broker ◀──poll── Consumer │ ▼ consume 처리 로직 동작 방식 Producer가 메시지 전송 Broker가 파티션에 메시지 저장 Consumer가 주기적으로 폴링 새 메시지 있으면 가져와서 처리 메시지 관리 Offset 관리 Offset: 파티션 내 메시지 위치 (0부터 시작) Committed Offset: 처리 완료한 마지막 위치 Latest Offset: 파티션의 마지막 메시지 위치 Consumer Lag: Latest - Committed (처리 지연 정도) Commit 전략 // 자동 커밋 (기본값) enable.auto.commit=true auto.commit.interval.ms=5000 // 수동 커밋 consumer.commitSync(); consumer.commitAsync(); 메시지 전달 보장 1. At-most-once 처리 전 commit 장점: 중복 없음 단점: 메시지 유실 가능 2. At-least-once (기본값) 처리 후 commit 장점: 메시지 유실 없음 단점: 중복 처리 가능 중요: 애플리케이션 레벨에서 멱등성 보장 필요 3. Exactly-once 트랜잭션 사용 장점: 중복도 유실도 없음 단점: 성능 오버헤드 메시지 보관 일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-27T00:00:00+09:00">
    <meta property="article:modified_time" content="2025-11-27T00:00:00+09:00">
    <meta property="article:tag" content="Kafka">
    <meta property="article:tag" content="Message Queue">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Apache Kafka 기본 개념 정리">
<meta name="twitter:description" content="Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.
아키텍처
Kafka Cluster (여러 Broker의 집합)
    │
    └─ Broker (카프카 서버, 여러 대 가능)
           │
           └─ Topic (메시지 종류)
                  │
                  ├─ Partition 0 ──┐
                  ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1
                  └─ Partition 2 ──┘                     ├─ Consumer 2
                          │                              └─ Consumer 3
                          │
                          └──────────── Consumer Group B ─── Consumer 1
구성 요소

Broker: Kafka 서버 (여러 대로 클러스터 구성)
Topic: 메시지 종류별 논리적 그룹
Partition: 토픽 내 병렬 처리 단위
Consumer Group: 동일 group.id로 묶인 컨슈머들

설계 시 고려사항

파티션 수 = 최대 병렬 처리 수
파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle)

용어 정리  ← 여기

  
      
          동작
          일반 메시지 큐
          Kafka
      
  
  
      
          메시지 보내기
          Publish
          Produce
      
      
          보내는 주체
          Publisher
          Producer
      
      
          토픽 구독
          Subscribe
          Subscribe (동일)
      
      
          메시지 받기
          Push (서버가 보냄)
          Poll (주기적으로 가져감)
      
      
          받는 주체
          Subscriber
          Consumer
      
  

메시지 흐름
Producer ──produce──▶ Kafka Broker ◀──poll── Consumer
                                                  │
                                                  ▼
                                              consume
                                              처리 로직
동작 방식

Producer가 메시지 전송
Broker가 파티션에 메시지 저장
Consumer가 주기적으로 폴링
새 메시지 있으면 가져와서 처리

메시지 관리
Offset 관리

Offset: 파티션 내 메시지 위치 (0부터 시작)
Committed Offset: 처리 완료한 마지막 위치
Latest Offset: 파티션의 마지막 메시지 위치
Consumer Lag: Latest - Committed (처리 지연 정도)

Commit 전략
// 자동 커밋 (기본값)
enable.auto.commit=true
auto.commit.interval.ms=5000

// 수동 커밋
consumer.commitSync();
consumer.commitAsync();
메시지 전달 보장
1. At-most-once

처리 전 commit
장점: 중복 없음
단점: 메시지 유실 가능

2. At-least-once (기본값)

처리 후 commit
장점: 메시지 유실 없음
단점: 중복 처리 가능
중요: 애플리케이션 레벨에서 멱등성 보장 필요

3. Exactly-once

트랜잭션 사용
장점: 중복도 유실도 없음
단점: 성능 오버헤드

메시지 보관
일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dont.kr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Apache Kafka 기본 개념 정리",
      "item": "https://dont.kr/posts/2025/2025-11-27-apache-kafka/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Apache Kafka 기본 개념 정리",
  "name": "Apache Kafka 기본 개념 정리",
  "description": "Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.\n아키텍처 Kafka Cluster (여러 Broker의 집합) │ └─ Broker (카프카 서버, 여러 대 가능) │ └─ Topic (메시지 종류) │ ├─ Partition 0 ──┐ ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1 └─ Partition 2 ──┘ ├─ Consumer 2 │ └─ Consumer 3 │ └──────────── Consumer Group B ─── Consumer 1 구성 요소 Broker: Kafka 서버 (여러 대로 클러스터 구성) Topic: 메시지 종류별 논리적 그룹 Partition: 토픽 내 병렬 처리 단위 Consumer Group: 동일 group.id로 묶인 컨슈머들 설계 시 고려사항 파티션 수 = 최대 병렬 처리 수 파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle) 용어 정리 ← 여기 동작 일반 메시지 큐 Kafka 메시지 보내기 Publish Produce 보내는 주체 Publisher Producer 토픽 구독 Subscribe Subscribe (동일) 메시지 받기 Push (서버가 보냄) Poll (주기적으로 가져감) 받는 주체 Subscriber Consumer 메시지 흐름 Producer ──produce──▶ Kafka Broker ◀──poll── Consumer │ ▼ consume 처리 로직 동작 방식 Producer가 메시지 전송 Broker가 파티션에 메시지 저장 Consumer가 주기적으로 폴링 새 메시지 있으면 가져와서 처리 메시지 관리 Offset 관리 Offset: 파티션 내 메시지 위치 (0부터 시작) Committed Offset: 처리 완료한 마지막 위치 Latest Offset: 파티션의 마지막 메시지 위치 Consumer Lag: Latest - Committed (처리 지연 정도) Commit 전략 // 자동 커밋 (기본값) enable.auto.commit=true auto.commit.interval.ms=5000 // 수동 커밋 consumer.commitSync(); consumer.commitAsync(); 메시지 전달 보장 1. At-most-once 처리 전 commit 장점: 중복 없음 단점: 메시지 유실 가능 2. At-least-once (기본값) 처리 후 commit 장점: 메시지 유실 없음 단점: 중복 처리 가능 중요: 애플리케이션 레벨에서 멱등성 보장 필요 3. Exactly-once 트랜잭션 사용 장점: 중복도 유실도 없음 단점: 성능 오버헤드 메시지 보관 일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:\n",
  "keywords": [
    "kafka", "message queue"
  ],
  "articleBody": "Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.\n아키텍처 Kafka Cluster (여러 Broker의 집합) │ └─ Broker (카프카 서버, 여러 대 가능) │ └─ Topic (메시지 종류) │ ├─ Partition 0 ──┐ ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1 └─ Partition 2 ──┘ ├─ Consumer 2 │ └─ Consumer 3 │ └──────────── Consumer Group B ─── Consumer 1 구성 요소 Broker: Kafka 서버 (여러 대로 클러스터 구성) Topic: 메시지 종류별 논리적 그룹 Partition: 토픽 내 병렬 처리 단위 Consumer Group: 동일 group.id로 묶인 컨슈머들 설계 시 고려사항 파티션 수 = 최대 병렬 처리 수 파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle) 용어 정리 ← 여기 동작 일반 메시지 큐 Kafka 메시지 보내기 Publish Produce 보내는 주체 Publisher Producer 토픽 구독 Subscribe Subscribe (동일) 메시지 받기 Push (서버가 보냄) Poll (주기적으로 가져감) 받는 주체 Subscriber Consumer 메시지 흐름 Producer ──produce──▶ Kafka Broker ◀──poll── Consumer │ ▼ consume 처리 로직 동작 방식 Producer가 메시지 전송 Broker가 파티션에 메시지 저장 Consumer가 주기적으로 폴링 새 메시지 있으면 가져와서 처리 메시지 관리 Offset 관리 Offset: 파티션 내 메시지 위치 (0부터 시작) Committed Offset: 처리 완료한 마지막 위치 Latest Offset: 파티션의 마지막 메시지 위치 Consumer Lag: Latest - Committed (처리 지연 정도) Commit 전략 // 자동 커밋 (기본값) enable.auto.commit=true auto.commit.interval.ms=5000 // 수동 커밋 consumer.commitSync(); consumer.commitAsync(); 메시지 전달 보장 1. At-most-once 처리 전 commit 장점: 중복 없음 단점: 메시지 유실 가능 2. At-least-once (기본값) 처리 후 commit 장점: 메시지 유실 없음 단점: 중복 처리 가능 중요: 애플리케이션 레벨에서 멱등성 보장 필요 3. Exactly-once 트랜잭션 사용 장점: 중복도 유실도 없음 단점: 성능 오버헤드 메시지 보관 일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:\n# 시간 기반 (기본 7일) log.retention.hours=168 # 용량 기반 log.retention.bytes=1073741824 # 압축 정책 log.cleanup.policy=delete # 기본값 log.cleanup.policy=compact # 키 기반 압축 장점 재처리 가능 여러 컨슈머 그룹이 독립적으로 소비 장애 복구 용이 정리 Kafka는 높은 처리량과 확장성을 제공하는 분산 메시징 시스템입니다. 특히:\n파티션을 통한 병렬 처리 컨슈머 그룹을 통한 부하 분산 메시지 보관을 통한 재처리 지원 이 특징들이 대용량 실시간 데이터 처리에 적합한 이유입니다.\n",
  "wordCount" : "335",
  "inLanguage": "ko",
  "datePublished": "2025-11-27T00:00:00+09:00",
  "dateModified": "2025-11-27T00:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dont.kr/posts/2025/2025-11-27-apache-kafka/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DoNT - Do Not Think!!!",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dont.kr/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dont.kr/" accesskey="h" title="DoNT - Do Not Think!!! (Alt + H)">DoNT - Do Not Think!!!</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dont.kr/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dont.kr/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Apache Kafka 기본 개념 정리
    </h1>
    <div class="post-meta"><span title='2025-11-27 00:00:00 +0900 KST'>2025년 11월 27일</span>

</div>
  </header> 
  <div class="post-content"><p>Apache Kafka의 핵심 개념과 동작 원리를 정리합니다.</p>
<h2 id="아키텍처">아키텍처<a hidden class="anchor" aria-hidden="true" href="#아키텍처">#</a></h2>
<pre tabindex="0"><code>Kafka Cluster (여러 Broker의 집합)
    │
    └─ Broker (카프카 서버, 여러 대 가능)
           │
           └─ Topic (메시지 종류)
                  │
                  ├─ Partition 0 ──┐
                  ├─ Partition 1 ──┼── Consumer Group A ─┬─ Consumer 1
                  └─ Partition 2 ──┘                     ├─ Consumer 2
                          │                              └─ Consumer 3
                          │
                          └──────────── Consumer Group B ─── Consumer 1
</code></pre><h3 id="구성-요소">구성 요소<a hidden class="anchor" aria-hidden="true" href="#구성-요소">#</a></h3>
<ul>
<li><strong>Broker</strong>: Kafka 서버 (여러 대로 클러스터 구성)</li>
<li><strong>Topic</strong>: 메시지 종류별 논리적 그룹</li>
<li><strong>Partition</strong>: 토픽 내 병렬 처리 단위</li>
<li><strong>Consumer Group</strong>: 동일 group.id로 묶인 컨슈머들</li>
</ul>
<h3 id="설계-시-고려사항">설계 시 고려사항<a hidden class="anchor" aria-hidden="true" href="#설계-시-고려사항">#</a></h3>
<ul>
<li>파티션 수 = 최대 병렬 처리 수</li>
<li>파티션 수 ≥ 컨슈머 수 (컨슈머가 더 많으면 일부는 idle)</li>
</ul>
<h2 id="용어-정리---여기">용어 정리  ← 여기<a hidden class="anchor" aria-hidden="true" href="#용어-정리---여기">#</a></h2>
<table>
  <thead>
      <tr>
          <th>동작</th>
          <th>일반 메시지 큐</th>
          <th>Kafka</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>메시지 보내기</td>
          <td>Publish</td>
          <td>Produce</td>
      </tr>
      <tr>
          <td>보내는 주체</td>
          <td>Publisher</td>
          <td>Producer</td>
      </tr>
      <tr>
          <td>토픽 구독</td>
          <td>Subscribe</td>
          <td>Subscribe (동일)</td>
      </tr>
      <tr>
          <td>메시지 받기</td>
          <td>Push (서버가 보냄)</td>
          <td>Poll (주기적으로 가져감)</td>
      </tr>
      <tr>
          <td>받는 주체</td>
          <td>Subscriber</td>
          <td>Consumer</td>
      </tr>
  </tbody>
</table>
<h2 id="메시지-흐름">메시지 흐름<a hidden class="anchor" aria-hidden="true" href="#메시지-흐름">#</a></h2>
<pre tabindex="0"><code>Producer ──produce──▶ Kafka Broker ◀──poll── Consumer
                                                  │
                                                  ▼
                                              consume
                                              처리 로직
</code></pre><h3 id="동작-방식">동작 방식<a hidden class="anchor" aria-hidden="true" href="#동작-방식">#</a></h3>
<ol>
<li>Producer가 메시지 전송</li>
<li>Broker가 파티션에 메시지 저장</li>
<li>Consumer가 주기적으로 폴링</li>
<li>새 메시지 있으면 가져와서 처리</li>
</ol>
<h2 id="메시지-관리">메시지 관리<a hidden class="anchor" aria-hidden="true" href="#메시지-관리">#</a></h2>
<h3 id="offset-관리">Offset 관리<a hidden class="anchor" aria-hidden="true" href="#offset-관리">#</a></h3>
<ul>
<li><strong>Offset</strong>: 파티션 내 메시지 위치 (0부터 시작)</li>
<li><strong>Committed Offset</strong>: 처리 완료한 마지막 위치</li>
<li><strong>Latest Offset</strong>: 파티션의 마지막 메시지 위치</li>
<li><strong>Consumer Lag</strong>: Latest - Committed (처리 지연 정도)</li>
</ul>
<h3 id="commit-전략">Commit 전략<a hidden class="anchor" aria-hidden="true" href="#commit-전략">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 자동 커밋 (기본값)</span>
</span></span><span style="display:flex;"><span>enable.<span style="color:#a6e22e">auto</span>.<span style="color:#a6e22e">commit</span><span style="color:#f92672">=</span><span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>auto.<span style="color:#a6e22e">commit</span>.<span style="color:#a6e22e">interval</span>.<span style="color:#a6e22e">ms</span><span style="color:#f92672">=</span>5000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 수동 커밋</span>
</span></span><span style="display:flex;"><span>consumer.<span style="color:#a6e22e">commitSync</span>();
</span></span><span style="display:flex;"><span>consumer.<span style="color:#a6e22e">commitAsync</span>();
</span></span></code></pre></div><h2 id="메시지-전달-보장">메시지 전달 보장<a hidden class="anchor" aria-hidden="true" href="#메시지-전달-보장">#</a></h2>
<h3 id="1-at-most-once">1. At-most-once<a hidden class="anchor" aria-hidden="true" href="#1-at-most-once">#</a></h3>
<ul>
<li>처리 전 commit</li>
<li>장점: 중복 없음</li>
<li>단점: 메시지 유실 가능</li>
</ul>
<h3 id="2-at-least-once-기본값">2. At-least-once (기본값)<a hidden class="anchor" aria-hidden="true" href="#2-at-least-once-기본값">#</a></h3>
<ul>
<li>처리 후 commit</li>
<li>장점: 메시지 유실 없음</li>
<li>단점: 중복 처리 가능</li>
<li><strong>중요</strong>: 애플리케이션 레벨에서 멱등성 보장 필요</li>
</ul>
<h3 id="3-exactly-once">3. Exactly-once<a hidden class="anchor" aria-hidden="true" href="#3-exactly-once">#</a></h3>
<ul>
<li>트랜잭션 사용</li>
<li>장점: 중복도 유실도 없음</li>
<li>단점: 성능 오버헤드</li>
</ul>
<h2 id="메시지-보관">메시지 보관<a hidden class="anchor" aria-hidden="true" href="#메시지-보관">#</a></h2>
<p>일반 메시지 큐와 달리 Kafka는 consume 후에도 메시지 보관:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#75715e"># 시간 기반 (기본 7일)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log.retention.hours</span><span style="color:#f92672">=</span><span style="color:#e6db74">168</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 용량 기반</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log.retention.bytes</span><span style="color:#f92672">=</span><span style="color:#e6db74">1073741824</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 압축 정책</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log.cleanup.policy</span><span style="color:#f92672">=</span><span style="color:#e6db74">delete  # 기본값</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log.cleanup.policy</span><span style="color:#f92672">=</span><span style="color:#e6db74">compact # 키 기반 압축</span>
</span></span></code></pre></div><h3 id="장점">장점<a hidden class="anchor" aria-hidden="true" href="#장점">#</a></h3>
<ul>
<li>재처리 가능</li>
<li>여러 컨슈머 그룹이 독립적으로 소비</li>
<li>장애 복구 용이</li>
</ul>
<h2 id="정리">정리<a hidden class="anchor" aria-hidden="true" href="#정리">#</a></h2>
<p>Kafka는 높은 처리량과 확장성을 제공하는 분산 메시징 시스템입니다. 특히:</p>
<ul>
<li>파티션을 통한 병렬 처리</li>
<li>컨슈머 그룹을 통한 부하 분산</li>
<li>메시지 보관을 통한 재처리 지원</li>
</ul>
<p>이 특징들이 대용량 실시간 데이터 처리에 적합한 이유입니다.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dont.kr/tags/kafka/">Kafka</a></li>
      <li><a href="https://dont.kr/tags/message-queue/">Message Queue</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
    data-repo="duddns/dontkr-www"
    data-repo-id="R_kgDOJ5uOLg"
    data-category="General"
    data-category-id="DIC_kwDOJ5uOLs4CzVRe"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="ko"
    crossorigin="anonymous"
    async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://dont.kr/">DoNT - Do Not Think!!!</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
