<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring Boot on DoNT - Do Not Think!!!</title>
    <link>https://dont.kr/tags/spring-boot/</link>
    <description>Recent content in Spring Boot on DoNT - Do Not Think!!!</description>
    <generator>Hugo -- 0.155.3</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 10 Feb 2026 00:00:00 +0900</lastBuildDate>
    <atom:link href="https://dont.kr/tags/spring-boot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AWS ECS에서 Java &#43; Spring Boot 어플리케이션 메모리 설정</title>
      <link>https://dont.kr/posts/2026/2026-02-10-ecs-jvm-memory/</link>
      <pubDate>Tue, 10 Feb 2026 00:00:00 +0900</pubDate>
      <guid>https://dont.kr/posts/2026/2026-02-10-ecs-jvm-memory/</guid>
      <description>&lt;h2 id=&#34;컨테이너-환경의-메모리-구조&#34;&gt;컨테이너 환경의 메모리 구조&lt;/h2&gt;
&lt;p&gt;기존 서버/VM 환경에서는 OS가 물리 메모리를 먼저 차지하고, 나머지를 JVM이 사용했습니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[VM/서버] 물리 메모리 → OS 커널 + 시스템 프로세스 → JVM
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECS 컨테이너는 다릅니다. 호스트 OS 커널을 공유하기 때문에, Task에 할당된 메모리는 거의 전부 컨테이너 프로세스(JVM)가 사용합니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[ECS Task] Task 메모리 ≈ JVM 전용
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;OS 몫을 남겨야 한다&amp;quot;는 상식은 컨테이너 환경에서는 불필요합니다. Fargate든 EC2든 Task 내부의 메모리 설정은 동일합니다.&lt;/p&gt;
&lt;h2 id=&#34;jvm-메모리-구조&#34;&gt;JVM 메모리 구조&lt;/h2&gt;
&lt;p&gt;JVM 메모리는 크게 Heap과 Non-Heap으로 나뉩니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot 설정 파일 로딩</title>
      <link>https://dont.kr/posts/2025/2025-11-26-spring-boot-config/</link>
      <pubDate>Wed, 26 Nov 2025 00:00:00 +0900</pubDate>
      <guid>https://dont.kr/posts/2025/2025-11-26-spring-boot-config/</guid>
      <description>&lt;p&gt;Spring Boot의 설정 파일 로딩 메커니즘과 외부 라이브러리 사용 시 발생하는 문제를 다룹니다.&lt;/p&gt;
&lt;h2 id=&#34;configdata-api-spring-boot-24&#34;&gt;ConfigData API (Spring Boot 2.4+)&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.4 부터 설정 로딩 방식이 ConfigData API로 변경되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-변경사항&#34;&gt;주요 변경사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring Cloud Bootstrap Context 대체 (bootstrap.yml → application.yml)&lt;/li&gt;
&lt;li&gt;단일 ApplicationContext 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.config.import&lt;/code&gt; 도입&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설정-파일-로딩-기본-동작&#34;&gt;설정 파일 로딩 기본 동작&lt;/h2&gt;
&lt;h3 id=&#34;검색-위치&#34;&gt;검색 위치&lt;/h3&gt;
&lt;p&gt;Spring Boot는 다음 위치에서 설정 파일을 검색합니다 (낮은 → 높은 우선순위):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. classpath:/application.yml
2. classpath:/config/application.yml
3. file:./application.yml
4. file:./config/application.yml
5. file:./config/*/application.yml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;로딩-규칙&#34;&gt;로딩 규칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 경로: 모두 로드 후 병합&lt;/li&gt;
&lt;li&gt;같은 classpath 경로: 첫 번째만 사용
&lt;ul&gt;
&lt;li&gt;Oracle Java 문서: 여러 모듈이 동일한 클래스 로더에 정의되고, 둘 이상의 모듈이 주어진 이름의 리소스를 포함하는 경우, 모듈이 검색되는 순서는 명시되지 않으며 매우 예측할 수 없을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;우선순위&#34;&gt;우선순위&lt;/h3&gt;
&lt;p&gt;나중에 로드된 것이 우선:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot 애플리케이션 웜업</title>
      <link>https://dont.kr/posts/2025/2025-11-25-spring-boot-warmup/</link>
      <pubDate>Tue, 25 Nov 2025 00:00:00 +0900</pubDate>
      <guid>https://dont.kr/posts/2025/2025-11-25-spring-boot-warmup/</guid>
      <description>&lt;p&gt;Spring Boot 배포 직후 첫 요청이 느린 이유를 JVM 동작 원리부터 설명합니다.&lt;/p&gt;
&lt;h2 id=&#34;컴파일러와-인터프리터&#34;&gt;컴파일러와 인터프리터&lt;/h2&gt;
&lt;h3 id=&#34;컴파일러-언어-cc&#34;&gt;컴파일러 언어 (C/C++)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전체 코드를 한번에 기계어로 변환&lt;/li&gt;
&lt;li&gt;실행 속도 빠름&lt;/li&gt;
&lt;li&gt;플랫폼 종속적&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인터프리터-언어-python&#34;&gt;인터프리터 언어 (Python)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 한 줄씩 해석하며 실행&lt;/li&gt;
&lt;li&gt;실행 속도 느림&lt;/li&gt;
&lt;li&gt;플랫폼 독립적&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;자바-동작-방식&#34;&gt;자바 동작 방식&lt;/h3&gt;
&lt;h4 id=&#34;자바-1990년대-설계-철학&#34;&gt;자바 1990년대 설계 철학&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;이식성: Write Once, Run Anywhere&lt;/li&gt;
&lt;li&gt;안전성: 메모리 보호, 타입 검증&lt;/li&gt;
&lt;li&gt;개발 생산성: 자동 메모리 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HelloWorld.java (소스코드) 
→ javac (컴파일)
→ HelloWorld.class (바이트코드)
→ java (JVM)
→ 실행
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;단점&#34;&gt;단점&lt;/h4&gt;
&lt;p&gt;바이트코드 인터프리터 실행으로 성능이 느렸습니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
